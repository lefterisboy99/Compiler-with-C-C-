Terminals unused in grammar

   SINGLE_LINE_COMMENT
   NESTED_COMMENT
   number


State 100 conflicts: 1 shift/reduce


Grammar

    0 $accept: program $end

    1 program: stmts

    2 stmts: stmts stmt
    3      | %empty

    4 stmt: expr ';'
    5     | ifstmt
    6     | whilestmt
    7     | forstmt
    8     | returnstmt
    9     | BREAK ';'
   10     | CONTINUE ';'
   11     | block
   12     | funcdef
   13     | ';'

   14 expr: assignexpr
   15     | expr '+' expr
   16     | expr '-' expr
   17     | expr '*' expr
   18     | expr '/' expr
   19     | expr '%' expr
   20     | expr GT expr
   21     | expr GE expr
   22     | expr LT expr
   23     | expr LE expr
   24     | expr EQ expr
   25     | expr NE expr
   26     | expr OR D expr
   27     | expr AND D expr
   28     | term

   29 D: %empty

   30 term: '(' expr ')'
   31     | '-' expr
   32     | NOT expr
   33     | PLUSPLUS lvalue
   34     | lvalue PLUSPLUS
   35     | MINUSMINUS lvalue
   36     | lvalue MINUSMINUS
   37     | primary

   38 assignexpr: lvalue '=' expr

   39 primary: lvalue
   40        | call
   41        | objectdef
   42        | '(' funcdef ')'
   43        | const

   44 lvalue: ID
   45       | LOCAL ID
   46       | COLONCOLON ID
   47       | member

   48 member: lvalue '.' ID
   49       | lvalue '[' expr ']'
   50       | call '.' ID
   51       | call '[' expr ']'

   52 call: call '(' elist ')'
   53     | lvalue callsuffix
   54     | '(' funcdef ')' '(' elist ')'

   55 callsuffix: normcall
   56           | methodcall

   57 normcall: '(' elist ')'

   58 methodcall: DOTDOT ID '(' elist ')'

   59 elist: expr
   60      | elist ',' expr
   61      | %empty

   62 $@1: %empty

   63 objectdef: '[' $@1 elist ']'
   64          | '[' indexed ']'

   65 indexed: indexedelem
   66        | indexed ',' indexedelem

   67 $@2: %empty

   68 indexedelem: '{' $@2 expr ':' expr '}'

   69 $@3: %empty

   70 block: '{' $@3 stmts '}'

   71 funcname: ID
   72         | %empty

   73 funcprefix: FUNCTION funcname

   74 $@4: %empty

   75 $@5: %empty

   76 funcargs: '(' $@4 idlist ')' $@5

   77 funcbody: block

   78 funcdef: funcprefix funcargs funcbody

   79 const: INTEGER
   80      | STRING
   81      | NIL
   82      | TRUE
   83      | FALSE
   84      | REAL

   85 idlist: ID
   86       | idlist ',' ID
   87       | %empty

   88 $@6: %empty

   89 ifprefix: IF $@6 '(' expr ')'

   90 elseprefix: ELSE

   91 ifstmt: ifprefix stmt

   92 $@7: %empty

   93 ifstmt: ifprefix stmt elseprefix stmt $@7

   94 whilestmt: whilestart whilecond stmt

   95 whilestart: WHILE

   96 whilecond: '(' expr ')'

   97 N: %empty

   98 M: %empty

   99 $@8: %empty

  100 forprefix: FOR $@8 '(' elist ';' M expr ';'

  101 $@9: %empty

  102 forstmt: forprefix N elist ')' N stmt $@9 N

  103 returnstmt: RETURN expr ';'
  104           | RETURN ';'


Terminals, with rules where they appear

$end (0) 0
'%' (37) 19
'(' (40) 30 42 52 54 57 58 76 89 96 100
')' (41) 30 42 52 54 57 58 76 89 96 102
'*' (42) 17
'+' (43) 15
',' (44) 60 66 86
'-' (45) 16 31
'.' (46) 48 50
'/' (47) 18
':' (58) 68
';' (59) 4 9 10 13 100 103 104
'=' (61) 38
'[' (91) 49 51 63 64
']' (93) 49 51 63 64
'{' (123) 68 70
'}' (125) 68 70
error (256)
IF (258) 89
ELSE (259) 90
WHILE (260) 95
FOR (261) 100
FUNCTION (262) 73
RETURN (263) 103 104
BREAK (264) 9
CONTINUE (265) 10
AND (266) 27
NOT (267) 32
OR (268) 26
LOCAL (269) 45
TRUE (270) 82
FALSE (271) 83
NIL (272) 81
EQ (273) 24
NE (274) 25
LT (275) 22
GT (276) 20
GE (277) 21
LE (278) 23
PLUSPLUS (279) 33 34
MINUSMINUS (280) 35 36
COLONCOLON (281) 46
DOTDOT (282) 58
SINGLE_LINE_COMMENT (283)
NESTED_COMMENT (284)
ID (285) 44 45 46 48 50 58 71 85 86
STRING (286) 80
INTEGER (287) 79
REAL (288) 84
number (289)
UMINUS (290)


Nonterminals, with rules where they appear

$accept (52)
    on left: 0
program (53)
    on left: 1, on right: 0
stmts (54)
    on left: 2 3, on right: 1 2 70
stmt (55)
    on left: 4 5 6 7 8 9 10 11 12 13, on right: 2 91 93 94 102
expr (56)
    on left: 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28, on right:
    4 15 16 17 18 19 20 21 22 23 24 25 26 27 30 31 32 38 49 51 59 60
    68 89 96 100 103
D (57)
    on left: 29, on right: 26 27
term (58)
    on left: 30 31 32 33 34 35 36 37, on right: 28
assignexpr (59)
    on left: 38, on right: 14
primary (60)
    on left: 39 40 41 42 43, on right: 37
lvalue (61)
    on left: 44 45 46 47, on right: 33 34 35 36 38 39 48 49 53
member (62)
    on left: 48 49 50 51, on right: 47
call (63)
    on left: 52 53 54, on right: 40 50 51 52
callsuffix (64)
    on left: 55 56, on right: 53
normcall (65)
    on left: 57, on right: 55
methodcall (66)
    on left: 58, on right: 56
elist (67)
    on left: 59 60 61, on right: 52 54 57 58 60 63 100 102
objectdef (68)
    on left: 63 64, on right: 41
$@1 (69)
    on left: 62, on right: 63
indexed (70)
    on left: 65 66, on right: 64 66
indexedelem (71)
    on left: 68, on right: 65 66
$@2 (72)
    on left: 67, on right: 68
block (73)
    on left: 70, on right: 11 77
$@3 (74)
    on left: 69, on right: 70
funcname (75)
    on left: 71 72, on right: 73
funcprefix (76)
    on left: 73, on right: 78
funcargs (77)
    on left: 76, on right: 78
$@4 (78)
    on left: 74, on right: 76
$@5 (79)
    on left: 75, on right: 76
funcbody (80)
    on left: 77, on right: 78
funcdef (81)
    on left: 78, on right: 12 42 54
const (82)
    on left: 79 80 81 82 83 84, on right: 43
idlist (83)
    on left: 85 86 87, on right: 76 86
ifprefix (84)
    on left: 89, on right: 91 93
$@6 (85)
    on left: 88, on right: 89
elseprefix (86)
    on left: 90, on right: 93
ifstmt (87)
    on left: 91 93, on right: 5
$@7 (88)
    on left: 92, on right: 93
whilestmt (89)
    on left: 94, on right: 6
whilestart (90)
    on left: 95, on right: 94
whilecond (91)
    on left: 96, on right: 94
N (92)
    on left: 97, on right: 102
M (93)
    on left: 98, on right: 100
forprefix (94)
    on left: 100, on right: 102
$@8 (95)
    on left: 99, on right: 100
forstmt (96)
    on left: 102, on right: 7
$@9 (97)
    on left: 101, on right: 102
returnstmt (98)
    on left: 103 104, on right: 8


State 0

    0 $accept: . program $end
    1 program: . stmts
    2 stmts: . stmts stmt
    3      | . %empty

    $default  reduce using rule 3 (stmts)

    program  go to state 1
    stmts    go to state 2


State 1

    0 $accept: program . $end

    $end  shift, and go to state 3


State 2

    1 program: stmts .  [$end]
    2 stmts: stmts . stmt
    4 stmt: . expr ';'
    5     | . ifstmt
    6     | . whilestmt
    7     | . forstmt
    8     | . returnstmt
    9     | . BREAK ';'
   10     | . CONTINUE ';'
   11     | . block
   12     | . funcdef
   13     | . ';'
   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   70 block: . '{' $@3 stmts '}'
   73 funcprefix: . FUNCTION funcname
   78 funcdef: . funcprefix funcargs funcbody
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL
   89 ifprefix: . IF $@6 '(' expr ')'
   91 ifstmt: . ifprefix stmt
   93       | . ifprefix stmt elseprefix stmt $@7
   94 whilestmt: . whilestart whilecond stmt
   95 whilestart: . WHILE
  100 forprefix: . FOR $@8 '(' elist ';' M expr ';'
  102 forstmt: . forprefix N elist ')' N stmt $@9 N
  103 returnstmt: . RETURN expr ';'
  104           | . RETURN ';'

    IF          shift, and go to state 4
    WHILE       shift, and go to state 5
    FOR         shift, and go to state 6
    FUNCTION    shift, and go to state 7
    RETURN      shift, and go to state 8
    BREAK       shift, and go to state 9
    CONTINUE    shift, and go to state 10
    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '{'         shift, and go to state 19
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    ';'         shift, and go to state 22
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    $default  reduce using rule 1 (program)

    stmt        go to state 28
    expr        go to state 29
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    block       go to state 37
    funcprefix  go to state 38
    funcdef     go to state 39
    const       go to state 40
    ifprefix    go to state 41
    ifstmt      go to state 42
    whilestmt   go to state 43
    whilestart  go to state 44
    forprefix   go to state 45
    forstmt     go to state 46
    returnstmt  go to state 47


State 3

    0 $accept: program $end .

    $default  accept


State 4

   88 $@6: . %empty
   89 ifprefix: IF . $@6 '(' expr ')'

    $default  reduce using rule 88 ($@6)

    $@6  go to state 48


State 5

   95 whilestart: WHILE .

    $default  reduce using rule 95 (whilestart)


State 6

   99 $@8: . %empty
  100 forprefix: FOR . $@8 '(' elist ';' M expr ';'

    $default  reduce using rule 99 ($@8)

    $@8  go to state 49


State 7

   71 funcname: . ID
   72         | . %empty  ['(']
   73 funcprefix: FUNCTION . funcname

    ID  shift, and go to state 50

    $default  reduce using rule 72 (funcname)

    funcname  go to state 51


State 8

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL
  103 returnstmt: RETURN . expr ';'
  104           | RETURN . ';'

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    ';'         shift, and go to state 52
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 53
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 9

    9 stmt: BREAK . ';'

    ';'  shift, and go to state 54


State 10

   10 stmt: CONTINUE . ';'

    ';'  shift, and go to state 55


State 11

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   32     | NOT . expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 56
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 12

   45 lvalue: LOCAL . ID

    ID  shift, and go to state 57


State 13

   82 const: TRUE .

    $default  reduce using rule 82 (const)


State 14

   83 const: FALSE .

    $default  reduce using rule 83 (const)


State 15

   81 const: NIL .

    $default  reduce using rule 81 (const)


State 16

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   31     | '-' . expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 58
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 17

   33 term: PLUSPLUS . lvalue
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'

    LOCAL       shift, and go to state 12
    '('         shift, and go to state 59
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24

    lvalue  go to state 60
    member  go to state 34
    call    go to state 61


State 18

   35 term: MINUSMINUS . lvalue
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'

    LOCAL       shift, and go to state 12
    '('         shift, and go to state 59
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24

    lvalue  go to state 62
    member  go to state 34
    call    go to state 61


State 19

   69 $@3: . %empty
   70 block: '{' . $@3 stmts '}'

    $default  reduce using rule 69 ($@3)

    $@3  go to state 63


State 20

   62 $@1: . %empty  [NOT, LOCAL, TRUE, FALSE, NIL, '-', PLUSPLUS, MINUSMINUS, '[', ']', '(', ',', COLONCOLON, ID, STRING, INTEGER, REAL]
   63 objectdef: '[' . $@1 elist ']'
   64          | '[' . indexed ']'
   65 indexed: . indexedelem
   66        | . indexed ',' indexedelem
   68 indexedelem: . '{' $@2 expr ':' expr '}'

    '{'  shift, and go to state 64

    $default  reduce using rule 62 ($@1)

    $@1          go to state 65
    indexed      go to state 66
    indexedelem  go to state 67


State 21

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   30     | '(' . expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   42        | '(' . funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   54     | '(' . funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   73 funcprefix: . FUNCTION funcname
   78 funcdef: . funcprefix funcargs funcbody
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    FUNCTION    shift, and go to state 7
    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 68
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    funcprefix  go to state 38
    funcdef     go to state 69
    const       go to state 40


State 22

   13 stmt: ';' .

    $default  reduce using rule 13 (stmt)


State 23

   46 lvalue: COLONCOLON . ID

    ID  shift, and go to state 70


State 24

   44 lvalue: ID .

    $default  reduce using rule 44 (lvalue)


State 25

   80 const: STRING .

    $default  reduce using rule 80 (const)


State 26

   79 const: INTEGER .

    $default  reduce using rule 79 (const)


State 27

   84 const: REAL .

    $default  reduce using rule 84 (const)


State 28

    2 stmts: stmts stmt .

    $default  reduce using rule 2 (stmts)


State 29

    4 stmt: expr . ';'
   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr

    AND  shift, and go to state 71
    OR   shift, and go to state 72
    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83
    ';'  shift, and go to state 84


State 30

   28 expr: term .

    $default  reduce using rule 28 (expr)


State 31

   14 expr: assignexpr .

    $default  reduce using rule 14 (expr)


State 32

   37 term: primary .

    $default  reduce using rule 37 (term)


State 33

   34 term: lvalue . PLUSPLUS
   36     | lvalue . MINUSMINUS
   38 assignexpr: lvalue . '=' expr
   39 primary: lvalue .  [AND, OR, '+', '-', '*', '/', '%', EQ, NE, LT, GT, GE, LE, '}', ']', ')', ';', ',', ':']
   48 member: lvalue . '.' ID
   49       | lvalue . '[' expr ']'
   53 call: lvalue . callsuffix
   55 callsuffix: . normcall
   56           | . methodcall
   57 normcall: . '(' elist ')'
   58 methodcall: . DOTDOT ID '(' elist ')'

    '='         shift, and go to state 85
    PLUSPLUS    shift, and go to state 86
    MINUSMINUS  shift, and go to state 87
    '['         shift, and go to state 88
    '('         shift, and go to state 89
    '.'         shift, and go to state 90
    DOTDOT      shift, and go to state 91

    $default  reduce using rule 39 (primary)

    callsuffix  go to state 92
    normcall    go to state 93
    methodcall  go to state 94


State 34

   47 lvalue: member .

    $default  reduce using rule 47 (lvalue)


State 35

   40 primary: call .  [AND, OR, '+', '-', '*', '/', '%', EQ, NE, LT, GT, GE, LE, '}', ']', ')', ';', ',', ':']
   50 member: call . '.' ID
   51       | call . '[' expr ']'
   52 call: call . '(' elist ')'

    '['  shift, and go to state 95
    '('  shift, and go to state 96
    '.'  shift, and go to state 97

    $default  reduce using rule 40 (primary)


State 36

   41 primary: objectdef .

    $default  reduce using rule 41 (primary)


State 37

   11 stmt: block .

    $default  reduce using rule 11 (stmt)


State 38

   76 funcargs: . '(' $@4 idlist ')' $@5
   78 funcdef: funcprefix . funcargs funcbody

    '('  shift, and go to state 98

    funcargs  go to state 99


State 39

   12 stmt: funcdef .

    $default  reduce using rule 12 (stmt)


State 40

   43 primary: const .

    $default  reduce using rule 43 (primary)


State 41

    4 stmt: . expr ';'
    5     | . ifstmt
    6     | . whilestmt
    7     | . forstmt
    8     | . returnstmt
    9     | . BREAK ';'
   10     | . CONTINUE ';'
   11     | . block
   12     | . funcdef
   13     | . ';'
   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   70 block: . '{' $@3 stmts '}'
   73 funcprefix: . FUNCTION funcname
   78 funcdef: . funcprefix funcargs funcbody
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL
   89 ifprefix: . IF $@6 '(' expr ')'
   91 ifstmt: . ifprefix stmt
   91       | ifprefix . stmt
   93       | . ifprefix stmt elseprefix stmt $@7
   93       | ifprefix . stmt elseprefix stmt $@7
   94 whilestmt: . whilestart whilecond stmt
   95 whilestart: . WHILE
  100 forprefix: . FOR $@8 '(' elist ';' M expr ';'
  102 forstmt: . forprefix N elist ')' N stmt $@9 N
  103 returnstmt: . RETURN expr ';'
  104           | . RETURN ';'

    IF          shift, and go to state 4
    WHILE       shift, and go to state 5
    FOR         shift, and go to state 6
    FUNCTION    shift, and go to state 7
    RETURN      shift, and go to state 8
    BREAK       shift, and go to state 9
    CONTINUE    shift, and go to state 10
    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '{'         shift, and go to state 19
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    ';'         shift, and go to state 22
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    stmt        go to state 100
    expr        go to state 29
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    block       go to state 37
    funcprefix  go to state 38
    funcdef     go to state 39
    const       go to state 40
    ifprefix    go to state 41
    ifstmt      go to state 42
    whilestmt   go to state 43
    whilestart  go to state 44
    forprefix   go to state 45
    forstmt     go to state 46
    returnstmt  go to state 47


State 42

    5 stmt: ifstmt .

    $default  reduce using rule 5 (stmt)


State 43

    6 stmt: whilestmt .

    $default  reduce using rule 6 (stmt)


State 44

   94 whilestmt: whilestart . whilecond stmt
   96 whilecond: . '(' expr ')'

    '('  shift, and go to state 101

    whilecond  go to state 102


State 45

   97 N: . %empty
  102 forstmt: forprefix . N elist ')' N stmt $@9 N

    $default  reduce using rule 97 (N)

    N  go to state 103


State 46

    7 stmt: forstmt .

    $default  reduce using rule 7 (stmt)


State 47

    8 stmt: returnstmt .

    $default  reduce using rule 8 (stmt)


State 48

   89 ifprefix: IF $@6 . '(' expr ')'

    '('  shift, and go to state 104


State 49

  100 forprefix: FOR $@8 . '(' elist ';' M expr ';'

    '('  shift, and go to state 105


State 50

   71 funcname: ID .

    $default  reduce using rule 71 (funcname)


State 51

   73 funcprefix: FUNCTION funcname .

    $default  reduce using rule 73 (funcprefix)


State 52

  104 returnstmt: RETURN ';' .

    $default  reduce using rule 104 (returnstmt)


State 53

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
  103 returnstmt: RETURN expr . ';'

    AND  shift, and go to state 71
    OR   shift, and go to state 72
    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83
    ';'  shift, and go to state 106


State 54

    9 stmt: BREAK ';' .

    $default  reduce using rule 9 (stmt)


State 55

   10 stmt: CONTINUE ';' .

    $default  reduce using rule 10 (stmt)


State 56

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
   32 term: NOT expr .  [AND, OR, '+', '-', '*', '/', '%', EQ, NE, LT, GT, GE, LE, '}', ']', ')', ';', ',', ':']

    $default  reduce using rule 32 (term)

    Conflict between rule 32 and token AND resolved as reduce (AND < NOT).
    Conflict between rule 32 and token OR resolved as reduce (OR < NOT).
    Conflict between rule 32 and token '+' resolved as reduce ('+' < NOT).
    Conflict between rule 32 and token '-' resolved as reduce ('-' < NOT).
    Conflict between rule 32 and token '*' resolved as reduce ('*' < NOT).
    Conflict between rule 32 and token '/' resolved as reduce ('/' < NOT).
    Conflict between rule 32 and token '%' resolved as reduce ('%' < NOT).
    Conflict between rule 32 and token EQ resolved as reduce (EQ < NOT).
    Conflict between rule 32 and token NE resolved as reduce (NE < NOT).
    Conflict between rule 32 and token LT resolved as reduce (LT < NOT).
    Conflict between rule 32 and token GT resolved as reduce (GT < NOT).
    Conflict between rule 32 and token GE resolved as reduce (GE < NOT).
    Conflict between rule 32 and token LE resolved as reduce (LE < NOT).


State 57

   45 lvalue: LOCAL ID .

    $default  reduce using rule 45 (lvalue)


State 58

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
   31 term: '-' expr .  [AND, OR, '+', '-', '*', '/', '%', EQ, NE, LT, GT, GE, LE, '}', ']', ')', ';', ',', ':']

    $default  reduce using rule 31 (term)

    Conflict between rule 31 and token AND resolved as reduce (AND < UMINUS).
    Conflict between rule 31 and token OR resolved as reduce (OR < UMINUS).
    Conflict between rule 31 and token '+' resolved as reduce ('+' < UMINUS).
    Conflict between rule 31 and token '-' resolved as reduce ('-' < UMINUS).
    Conflict between rule 31 and token '*' resolved as reduce ('*' < UMINUS).
    Conflict between rule 31 and token '/' resolved as reduce ('/' < UMINUS).
    Conflict between rule 31 and token '%' resolved as reduce ('%' < UMINUS).
    Conflict between rule 31 and token EQ resolved as reduce (EQ < UMINUS).
    Conflict between rule 31 and token NE resolved as reduce (NE < UMINUS).
    Conflict between rule 31 and token LT resolved as reduce (LT < UMINUS).
    Conflict between rule 31 and token GT resolved as reduce (GT < UMINUS).
    Conflict between rule 31 and token GE resolved as reduce (GE < UMINUS).
    Conflict between rule 31 and token LE resolved as reduce (LE < UMINUS).


State 59

   54 call: '(' . funcdef ')' '(' elist ')'
   73 funcprefix: . FUNCTION funcname
   78 funcdef: . funcprefix funcargs funcbody

    FUNCTION  shift, and go to state 7

    funcprefix  go to state 38
    funcdef     go to state 107


State 60

   33 term: PLUSPLUS lvalue .  [AND, OR, '+', '-', '*', '/', '%', EQ, NE, LT, GT, GE, LE, '}', ']', ')', ';', ',', ':']
   48 member: lvalue . '.' ID
   49       | lvalue . '[' expr ']'
   53 call: lvalue . callsuffix
   55 callsuffix: . normcall
   56           | . methodcall
   57 normcall: . '(' elist ')'
   58 methodcall: . DOTDOT ID '(' elist ')'

    '['     shift, and go to state 88
    '('     shift, and go to state 89
    '.'     shift, and go to state 90
    DOTDOT  shift, and go to state 91

    $default  reduce using rule 33 (term)

    callsuffix  go to state 92
    normcall    go to state 93
    methodcall  go to state 94


State 61

   50 member: call . '.' ID
   51       | call . '[' expr ']'
   52 call: call . '(' elist ')'

    '['  shift, and go to state 95
    '('  shift, and go to state 96
    '.'  shift, and go to state 97


State 62

   35 term: MINUSMINUS lvalue .  [AND, OR, '+', '-', '*', '/', '%', EQ, NE, LT, GT, GE, LE, '}', ']', ')', ';', ',', ':']
   48 member: lvalue . '.' ID
   49       | lvalue . '[' expr ']'
   53 call: lvalue . callsuffix
   55 callsuffix: . normcall
   56           | . methodcall
   57 normcall: . '(' elist ')'
   58 methodcall: . DOTDOT ID '(' elist ')'

    '['     shift, and go to state 88
    '('     shift, and go to state 89
    '.'     shift, and go to state 90
    DOTDOT  shift, and go to state 91

    $default  reduce using rule 35 (term)

    callsuffix  go to state 92
    normcall    go to state 93
    methodcall  go to state 94


State 63

    2 stmts: . stmts stmt
    3      | . %empty
   70 block: '{' $@3 . stmts '}'

    $default  reduce using rule 3 (stmts)

    stmts  go to state 108


State 64

   67 $@2: . %empty
   68 indexedelem: '{' . $@2 expr ':' expr '}'

    $default  reduce using rule 67 ($@2)

    $@2  go to state 109


State 65

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   59 elist: . expr
   60      | . elist ',' expr
   61      | . %empty  [']', ',']
   63 objectdef: . '[' $@1 elist ']'
   63          | '[' $@1 . elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    $default  reduce using rule 61 (elist)

    expr        go to state 110
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    elist       go to state 111
    objectdef   go to state 36
    const       go to state 40


State 66

   64 objectdef: '[' indexed . ']'
   66 indexed: indexed . ',' indexedelem

    ']'  shift, and go to state 112
    ','  shift, and go to state 113


State 67

   65 indexed: indexedelem .

    $default  reduce using rule 65 (indexed)


State 68

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
   30 term: '(' expr . ')'

    AND  shift, and go to state 71
    OR   shift, and go to state 72
    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83
    ')'  shift, and go to state 114


State 69

   42 primary: '(' funcdef . ')'
   54 call: '(' funcdef . ')' '(' elist ')'

    ')'  shift, and go to state 115


State 70

   46 lvalue: COLONCOLON ID .

    $default  reduce using rule 46 (lvalue)


State 71

   27 expr: expr AND . D expr
   29 D: . %empty

    $default  reduce using rule 29 (D)

    D  go to state 116


State 72

   26 expr: expr OR . D expr
   29 D: . %empty

    $default  reduce using rule 29 (D)

    D  go to state 117


State 73

   14 expr: . assignexpr
   15     | . expr '+' expr
   15     | expr '+' . expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 118
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 74

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   16     | expr '-' . expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 119
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 75

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   17     | expr '*' . expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 120
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 76

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   18     | expr '/' . expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 121
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 77

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   19     | expr '%' . expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 122
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 78

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   24     | expr EQ . expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 123
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 79

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   25     | expr NE . expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 124
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 80

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   22     | expr LT . expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 125
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 81

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   20     | expr GT . expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 126
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 82

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   21     | expr GE . expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 127
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 83

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   23     | expr LE . expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 128
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 84

    4 stmt: expr ';' .

    $default  reduce using rule 4 (stmt)


State 85

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   38           | lvalue '=' . expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 129
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 86

   34 term: lvalue PLUSPLUS .

    $default  reduce using rule 34 (term)


State 87

   36 term: lvalue MINUSMINUS .

    $default  reduce using rule 36 (term)


State 88

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   49       | lvalue '[' . expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 130
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 89

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   57 normcall: '(' . elist ')'
   59 elist: . expr
   60      | . elist ',' expr
   61      | . %empty  [')', ',']
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    $default  reduce using rule 61 (elist)

    expr        go to state 110
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    elist       go to state 131
    objectdef   go to state 36
    const       go to state 40


State 90

   48 member: lvalue '.' . ID

    ID  shift, and go to state 132


State 91

   58 methodcall: DOTDOT . ID '(' elist ')'

    ID  shift, and go to state 133


State 92

   53 call: lvalue callsuffix .

    $default  reduce using rule 53 (call)


State 93

   55 callsuffix: normcall .

    $default  reduce using rule 55 (callsuffix)


State 94

   56 callsuffix: methodcall .

    $default  reduce using rule 56 (callsuffix)


State 95

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   51       | call '[' . expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 134
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 96

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   52     | call '(' . elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   59 elist: . expr
   60      | . elist ',' expr
   61      | . %empty  [')', ',']
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    $default  reduce using rule 61 (elist)

    expr        go to state 110
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    elist       go to state 135
    objectdef   go to state 36
    const       go to state 40


State 97

   50 member: call '.' . ID

    ID  shift, and go to state 136


State 98

   74 $@4: . %empty
   76 funcargs: '(' . $@4 idlist ')' $@5

    $default  reduce using rule 74 ($@4)

    $@4  go to state 137


State 99

   70 block: . '{' $@3 stmts '}'
   77 funcbody: . block
   78 funcdef: funcprefix funcargs . funcbody

    '{'  shift, and go to state 19

    block     go to state 138
    funcbody  go to state 139


State 100

   90 elseprefix: . ELSE
   91 ifstmt: ifprefix stmt .  [$end, IF, ELSE, WHILE, FOR, FUNCTION, RETURN, BREAK, CONTINUE, NOT, LOCAL, TRUE, FALSE, NIL, '-', PLUSPLUS, MINUSMINUS, '{', '}', '[', '(', ';', COLONCOLON, ID, STRING, INTEGER, REAL]
   93       | ifprefix stmt . elseprefix stmt $@7

    ELSE  shift, and go to state 140

    ELSE      [reduce using rule 91 (ifstmt)]
    $default  reduce using rule 91 (ifstmt)

    elseprefix  go to state 141


State 101

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL
   96 whilecond: '(' . expr ')'

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 142
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 102

    4 stmt: . expr ';'
    5     | . ifstmt
    6     | . whilestmt
    7     | . forstmt
    8     | . returnstmt
    9     | . BREAK ';'
   10     | . CONTINUE ';'
   11     | . block
   12     | . funcdef
   13     | . ';'
   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   70 block: . '{' $@3 stmts '}'
   73 funcprefix: . FUNCTION funcname
   78 funcdef: . funcprefix funcargs funcbody
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL
   89 ifprefix: . IF $@6 '(' expr ')'
   91 ifstmt: . ifprefix stmt
   93       | . ifprefix stmt elseprefix stmt $@7
   94 whilestmt: . whilestart whilecond stmt
   94          | whilestart whilecond . stmt
   95 whilestart: . WHILE
  100 forprefix: . FOR $@8 '(' elist ';' M expr ';'
  102 forstmt: . forprefix N elist ')' N stmt $@9 N
  103 returnstmt: . RETURN expr ';'
  104           | . RETURN ';'

    IF          shift, and go to state 4
    WHILE       shift, and go to state 5
    FOR         shift, and go to state 6
    FUNCTION    shift, and go to state 7
    RETURN      shift, and go to state 8
    BREAK       shift, and go to state 9
    CONTINUE    shift, and go to state 10
    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '{'         shift, and go to state 19
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    ';'         shift, and go to state 22
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    stmt        go to state 143
    expr        go to state 29
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    block       go to state 37
    funcprefix  go to state 38
    funcdef     go to state 39
    const       go to state 40
    ifprefix    go to state 41
    ifstmt      go to state 42
    whilestmt   go to state 43
    whilestart  go to state 44
    forprefix   go to state 45
    forstmt     go to state 46
    returnstmt  go to state 47


State 103

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   59 elist: . expr
   60      | . elist ',' expr
   61      | . %empty  [')', ',']
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL
  102 forstmt: forprefix N . elist ')' N stmt $@9 N

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    $default  reduce using rule 61 (elist)

    expr        go to state 110
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    elist       go to state 144
    objectdef   go to state 36
    const       go to state 40


State 104

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL
   89 ifprefix: IF $@6 '(' . expr ')'

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 145
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 105

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   59 elist: . expr
   60      | . elist ',' expr
   61      | . %empty  [';', ',']
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL
  100 forprefix: FOR $@8 '(' . elist ';' M expr ';'

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    $default  reduce using rule 61 (elist)

    expr        go to state 110
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    elist       go to state 146
    objectdef   go to state 36
    const       go to state 40


State 106

  103 returnstmt: RETURN expr ';' .

    $default  reduce using rule 103 (returnstmt)


State 107

   54 call: '(' funcdef . ')' '(' elist ')'

    ')'  shift, and go to state 147


State 108

    2 stmts: stmts . stmt
    4 stmt: . expr ';'
    5     | . ifstmt
    6     | . whilestmt
    7     | . forstmt
    8     | . returnstmt
    9     | . BREAK ';'
   10     | . CONTINUE ';'
   11     | . block
   12     | . funcdef
   13     | . ';'
   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   70 block: . '{' $@3 stmts '}'
   70      | '{' $@3 stmts . '}'
   73 funcprefix: . FUNCTION funcname
   78 funcdef: . funcprefix funcargs funcbody
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL
   89 ifprefix: . IF $@6 '(' expr ')'
   91 ifstmt: . ifprefix stmt
   93       | . ifprefix stmt elseprefix stmt $@7
   94 whilestmt: . whilestart whilecond stmt
   95 whilestart: . WHILE
  100 forprefix: . FOR $@8 '(' elist ';' M expr ';'
  102 forstmt: . forprefix N elist ')' N stmt $@9 N
  103 returnstmt: . RETURN expr ';'
  104           | . RETURN ';'

    IF          shift, and go to state 4
    WHILE       shift, and go to state 5
    FOR         shift, and go to state 6
    FUNCTION    shift, and go to state 7
    RETURN      shift, and go to state 8
    BREAK       shift, and go to state 9
    CONTINUE    shift, and go to state 10
    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '{'         shift, and go to state 19
    '}'         shift, and go to state 148
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    ';'         shift, and go to state 22
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    stmt        go to state 28
    expr        go to state 29
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    block       go to state 37
    funcprefix  go to state 38
    funcdef     go to state 39
    const       go to state 40
    ifprefix    go to state 41
    ifstmt      go to state 42
    whilestmt   go to state 43
    whilestart  go to state 44
    forprefix   go to state 45
    forstmt     go to state 46
    returnstmt  go to state 47


State 109

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   68 indexedelem: '{' $@2 . expr ':' expr '}'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 149
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 110

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
   59 elist: expr .  [']', ')', ';', ',']

    AND  shift, and go to state 71
    OR   shift, and go to state 72
    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83

    $default  reduce using rule 59 (elist)


State 111

   60 elist: elist . ',' expr
   63 objectdef: '[' $@1 elist . ']'

    ']'  shift, and go to state 150
    ','  shift, and go to state 151


State 112

   64 objectdef: '[' indexed ']' .

    $default  reduce using rule 64 (objectdef)


State 113

   66 indexed: indexed ',' . indexedelem
   68 indexedelem: . '{' $@2 expr ':' expr '}'

    '{'  shift, and go to state 64

    indexedelem  go to state 152


State 114

   30 term: '(' expr ')' .

    $default  reduce using rule 30 (term)


State 115

   42 primary: '(' funcdef ')' .  [AND, OR, '+', '-', '*', '/', '%', EQ, NE, LT, GT, GE, LE, '}', ']', ')', ';', ',', ':']
   54 call: '(' funcdef ')' . '(' elist ')'

    '('  shift, and go to state 153

    $default  reduce using rule 42 (primary)


State 116

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   27     | expr AND D . expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 154
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 117

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   26     | expr OR D . expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 155
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 118

   15 expr: expr . '+' expr
   15     | expr '+' expr .  [AND, OR, '+', '-', EQ, NE, LT, GT, GE, LE, '}', ']', ')', ';', ',', ':']
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr

    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77

    $default  reduce using rule 15 (expr)

    Conflict between rule 15 and token AND resolved as reduce (AND < '+').
    Conflict between rule 15 and token OR resolved as reduce (OR < '+').
    Conflict between rule 15 and token '+' resolved as reduce (%left '+').
    Conflict between rule 15 and token '-' resolved as reduce (%left '-').
    Conflict between rule 15 and token '*' resolved as shift ('+' < '*').
    Conflict between rule 15 and token '/' resolved as shift ('+' < '/').
    Conflict between rule 15 and token '%' resolved as shift ('+' < '%').
    Conflict between rule 15 and token EQ resolved as reduce (EQ < '+').
    Conflict between rule 15 and token NE resolved as reduce (NE < '+').
    Conflict between rule 15 and token LT resolved as reduce (LT < '+').
    Conflict between rule 15 and token GT resolved as reduce (GT < '+').
    Conflict between rule 15 and token GE resolved as reduce (GE < '+').
    Conflict between rule 15 and token LE resolved as reduce (LE < '+').


State 119

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   16     | expr '-' expr .  [AND, OR, '+', '-', EQ, NE, LT, GT, GE, LE, '}', ']', ')', ';', ',', ':']
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr

    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77

    $default  reduce using rule 16 (expr)

    Conflict between rule 16 and token AND resolved as reduce (AND < '-').
    Conflict between rule 16 and token OR resolved as reduce (OR < '-').
    Conflict between rule 16 and token '+' resolved as reduce (%left '+').
    Conflict between rule 16 and token '-' resolved as reduce (%left '-').
    Conflict between rule 16 and token '*' resolved as shift ('-' < '*').
    Conflict between rule 16 and token '/' resolved as shift ('-' < '/').
    Conflict between rule 16 and token '%' resolved as shift ('-' < '%').
    Conflict between rule 16 and token EQ resolved as reduce (EQ < '-').
    Conflict between rule 16 and token NE resolved as reduce (NE < '-').
    Conflict between rule 16 and token LT resolved as reduce (LT < '-').
    Conflict between rule 16 and token GT resolved as reduce (GT < '-').
    Conflict between rule 16 and token GE resolved as reduce (GE < '-').
    Conflict between rule 16 and token LE resolved as reduce (LE < '-').


State 120

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   17     | expr '*' expr .  [AND, OR, '+', '-', '*', '/', '%', EQ, NE, LT, GT, GE, LE, '}', ']', ')', ';', ',', ':']
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr

    $default  reduce using rule 17 (expr)

    Conflict between rule 17 and token AND resolved as reduce (AND < '*').
    Conflict between rule 17 and token OR resolved as reduce (OR < '*').
    Conflict between rule 17 and token '+' resolved as reduce ('+' < '*').
    Conflict between rule 17 and token '-' resolved as reduce ('-' < '*').
    Conflict between rule 17 and token '*' resolved as reduce (%left '*').
    Conflict between rule 17 and token '/' resolved as reduce (%left '/').
    Conflict between rule 17 and token '%' resolved as reduce (%left '%').
    Conflict between rule 17 and token EQ resolved as reduce (EQ < '*').
    Conflict between rule 17 and token NE resolved as reduce (NE < '*').
    Conflict between rule 17 and token LT resolved as reduce (LT < '*').
    Conflict between rule 17 and token GT resolved as reduce (GT < '*').
    Conflict between rule 17 and token GE resolved as reduce (GE < '*').
    Conflict between rule 17 and token LE resolved as reduce (LE < '*').


State 121

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   18     | expr '/' expr .  [AND, OR, '+', '-', '*', '/', '%', EQ, NE, LT, GT, GE, LE, '}', ']', ')', ';', ',', ':']
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr

    $default  reduce using rule 18 (expr)

    Conflict between rule 18 and token AND resolved as reduce (AND < '/').
    Conflict between rule 18 and token OR resolved as reduce (OR < '/').
    Conflict between rule 18 and token '+' resolved as reduce ('+' < '/').
    Conflict between rule 18 and token '-' resolved as reduce ('-' < '/').
    Conflict between rule 18 and token '*' resolved as reduce (%left '*').
    Conflict between rule 18 and token '/' resolved as reduce (%left '/').
    Conflict between rule 18 and token '%' resolved as reduce (%left '%').
    Conflict between rule 18 and token EQ resolved as reduce (EQ < '/').
    Conflict between rule 18 and token NE resolved as reduce (NE < '/').
    Conflict between rule 18 and token LT resolved as reduce (LT < '/').
    Conflict between rule 18 and token GT resolved as reduce (GT < '/').
    Conflict between rule 18 and token GE resolved as reduce (GE < '/').
    Conflict between rule 18 and token LE resolved as reduce (LE < '/').


State 122

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   19     | expr '%' expr .  [AND, OR, '+', '-', '*', '/', '%', EQ, NE, LT, GT, GE, LE, '}', ']', ')', ';', ',', ':']
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr

    $default  reduce using rule 19 (expr)

    Conflict between rule 19 and token AND resolved as reduce (AND < '%').
    Conflict between rule 19 and token OR resolved as reduce (OR < '%').
    Conflict between rule 19 and token '+' resolved as reduce ('+' < '%').
    Conflict between rule 19 and token '-' resolved as reduce ('-' < '%').
    Conflict between rule 19 and token '*' resolved as reduce (%left '*').
    Conflict between rule 19 and token '/' resolved as reduce (%left '/').
    Conflict between rule 19 and token '%' resolved as reduce (%left '%').
    Conflict between rule 19 and token EQ resolved as reduce (EQ < '%').
    Conflict between rule 19 and token NE resolved as reduce (NE < '%').
    Conflict between rule 19 and token LT resolved as reduce (LT < '%').
    Conflict between rule 19 and token GT resolved as reduce (GT < '%').
    Conflict between rule 19 and token GE resolved as reduce (GE < '%').
    Conflict between rule 19 and token LE resolved as reduce (LE < '%').


State 123

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   24     | expr EQ expr .  [AND, OR, '}', ']', ')', ';', ',', ':']
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr

    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83

    EQ  error (nonassociative)
    NE  error (nonassociative)

    $default  reduce using rule 24 (expr)

    Conflict between rule 24 and token AND resolved as reduce (AND < EQ).
    Conflict between rule 24 and token OR resolved as reduce (OR < EQ).
    Conflict between rule 24 and token '+' resolved as shift (EQ < '+').
    Conflict between rule 24 and token '-' resolved as shift (EQ < '-').
    Conflict between rule 24 and token '*' resolved as shift (EQ < '*').
    Conflict between rule 24 and token '/' resolved as shift (EQ < '/').
    Conflict between rule 24 and token '%' resolved as shift (EQ < '%').
    Conflict between rule 24 and token EQ resolved as an error (%nonassoc EQ).
    Conflict between rule 24 and token NE resolved as an error (%nonassoc NE).
    Conflict between rule 24 and token LT resolved as shift (EQ < LT).
    Conflict between rule 24 and token GT resolved as shift (EQ < GT).
    Conflict between rule 24 and token GE resolved as shift (EQ < GE).
    Conflict between rule 24 and token LE resolved as shift (EQ < LE).


State 124

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   25     | expr NE expr .  [AND, OR, '}', ']', ')', ';', ',', ':']
   26     | expr . OR D expr
   27     | expr . AND D expr

    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83

    EQ  error (nonassociative)
    NE  error (nonassociative)

    $default  reduce using rule 25 (expr)

    Conflict between rule 25 and token AND resolved as reduce (AND < NE).
    Conflict between rule 25 and token OR resolved as reduce (OR < NE).
    Conflict between rule 25 and token '+' resolved as shift (NE < '+').
    Conflict between rule 25 and token '-' resolved as shift (NE < '-').
    Conflict between rule 25 and token '*' resolved as shift (NE < '*').
    Conflict between rule 25 and token '/' resolved as shift (NE < '/').
    Conflict between rule 25 and token '%' resolved as shift (NE < '%').
    Conflict between rule 25 and token EQ resolved as an error (%nonassoc EQ).
    Conflict between rule 25 and token NE resolved as an error (%nonassoc NE).
    Conflict between rule 25 and token LT resolved as shift (NE < LT).
    Conflict between rule 25 and token GT resolved as shift (NE < GT).
    Conflict between rule 25 and token GE resolved as shift (NE < GE).
    Conflict between rule 25 and token LE resolved as shift (NE < LE).


State 125

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   22     | expr LT expr .  [AND, OR, EQ, NE, '}', ']', ')', ';', ',', ':']
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr

    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77

    LT  error (nonassociative)
    GT  error (nonassociative)
    GE  error (nonassociative)
    LE  error (nonassociative)

    $default  reduce using rule 22 (expr)

    Conflict between rule 22 and token AND resolved as reduce (AND < LT).
    Conflict between rule 22 and token OR resolved as reduce (OR < LT).
    Conflict between rule 22 and token '+' resolved as shift (LT < '+').
    Conflict between rule 22 and token '-' resolved as shift (LT < '-').
    Conflict between rule 22 and token '*' resolved as shift (LT < '*').
    Conflict between rule 22 and token '/' resolved as shift (LT < '/').
    Conflict between rule 22 and token '%' resolved as shift (LT < '%').
    Conflict between rule 22 and token EQ resolved as reduce (EQ < LT).
    Conflict between rule 22 and token NE resolved as reduce (NE < LT).
    Conflict between rule 22 and token LT resolved as an error (%nonassoc LT).
    Conflict between rule 22 and token GT resolved as an error (%nonassoc GT).
    Conflict between rule 22 and token GE resolved as an error (%nonassoc GE).
    Conflict between rule 22 and token LE resolved as an error (%nonassoc LE).


State 126

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   20     | expr GT expr .  [AND, OR, EQ, NE, '}', ']', ')', ';', ',', ':']
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr

    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77

    LT  error (nonassociative)
    GT  error (nonassociative)
    GE  error (nonassociative)
    LE  error (nonassociative)

    $default  reduce using rule 20 (expr)

    Conflict between rule 20 and token AND resolved as reduce (AND < GT).
    Conflict between rule 20 and token OR resolved as reduce (OR < GT).
    Conflict between rule 20 and token '+' resolved as shift (GT < '+').
    Conflict between rule 20 and token '-' resolved as shift (GT < '-').
    Conflict between rule 20 and token '*' resolved as shift (GT < '*').
    Conflict between rule 20 and token '/' resolved as shift (GT < '/').
    Conflict between rule 20 and token '%' resolved as shift (GT < '%').
    Conflict between rule 20 and token EQ resolved as reduce (EQ < GT).
    Conflict between rule 20 and token NE resolved as reduce (NE < GT).
    Conflict between rule 20 and token LT resolved as an error (%nonassoc LT).
    Conflict between rule 20 and token GT resolved as an error (%nonassoc GT).
    Conflict between rule 20 and token GE resolved as an error (%nonassoc GE).
    Conflict between rule 20 and token LE resolved as an error (%nonassoc LE).


State 127

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   21     | expr GE expr .  [AND, OR, EQ, NE, '}', ']', ')', ';', ',', ':']
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr

    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77

    LT  error (nonassociative)
    GT  error (nonassociative)
    GE  error (nonassociative)
    LE  error (nonassociative)

    $default  reduce using rule 21 (expr)

    Conflict between rule 21 and token AND resolved as reduce (AND < GE).
    Conflict between rule 21 and token OR resolved as reduce (OR < GE).
    Conflict between rule 21 and token '+' resolved as shift (GE < '+').
    Conflict between rule 21 and token '-' resolved as shift (GE < '-').
    Conflict between rule 21 and token '*' resolved as shift (GE < '*').
    Conflict between rule 21 and token '/' resolved as shift (GE < '/').
    Conflict between rule 21 and token '%' resolved as shift (GE < '%').
    Conflict between rule 21 and token EQ resolved as reduce (EQ < GE).
    Conflict between rule 21 and token NE resolved as reduce (NE < GE).
    Conflict between rule 21 and token LT resolved as an error (%nonassoc LT).
    Conflict between rule 21 and token GT resolved as an error (%nonassoc GT).
    Conflict between rule 21 and token GE resolved as an error (%nonassoc GE).
    Conflict between rule 21 and token LE resolved as an error (%nonassoc LE).


State 128

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   23     | expr LE expr .  [AND, OR, EQ, NE, '}', ']', ')', ';', ',', ':']
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr

    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77

    LT  error (nonassociative)
    GT  error (nonassociative)
    GE  error (nonassociative)
    LE  error (nonassociative)

    $default  reduce using rule 23 (expr)

    Conflict between rule 23 and token AND resolved as reduce (AND < LE).
    Conflict between rule 23 and token OR resolved as reduce (OR < LE).
    Conflict between rule 23 and token '+' resolved as shift (LE < '+').
    Conflict between rule 23 and token '-' resolved as shift (LE < '-').
    Conflict between rule 23 and token '*' resolved as shift (LE < '*').
    Conflict between rule 23 and token '/' resolved as shift (LE < '/').
    Conflict between rule 23 and token '%' resolved as shift (LE < '%').
    Conflict between rule 23 and token EQ resolved as reduce (EQ < LE).
    Conflict between rule 23 and token NE resolved as reduce (NE < LE).
    Conflict between rule 23 and token LT resolved as an error (%nonassoc LT).
    Conflict between rule 23 and token GT resolved as an error (%nonassoc GT).
    Conflict between rule 23 and token GE resolved as an error (%nonassoc GE).
    Conflict between rule 23 and token LE resolved as an error (%nonassoc LE).


State 129

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
   38 assignexpr: lvalue '=' expr .  ['}', ']', ')', ';', ',', ':']

    AND  shift, and go to state 71
    OR   shift, and go to state 72
    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83

    $default  reduce using rule 38 (assignexpr)

    Conflict between rule 38 and token AND resolved as shift ('=' < AND).
    Conflict between rule 38 and token OR resolved as shift ('=' < OR).
    Conflict between rule 38 and token '+' resolved as shift ('=' < '+').
    Conflict between rule 38 and token '-' resolved as shift ('=' < '-').
    Conflict between rule 38 and token '*' resolved as shift ('=' < '*').
    Conflict between rule 38 and token '/' resolved as shift ('=' < '/').
    Conflict between rule 38 and token '%' resolved as shift ('=' < '%').
    Conflict between rule 38 and token EQ resolved as shift ('=' < EQ).
    Conflict between rule 38 and token NE resolved as shift ('=' < NE).
    Conflict between rule 38 and token LT resolved as shift ('=' < LT).
    Conflict between rule 38 and token GT resolved as shift ('=' < GT).
    Conflict between rule 38 and token GE resolved as shift ('=' < GE).
    Conflict between rule 38 and token LE resolved as shift ('=' < LE).


State 130

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
   49 member: lvalue '[' expr . ']'

    AND  shift, and go to state 71
    OR   shift, and go to state 72
    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83
    ']'  shift, and go to state 156


State 131

   57 normcall: '(' elist . ')'
   60 elist: elist . ',' expr

    ')'  shift, and go to state 157
    ','  shift, and go to state 151


State 132

   48 member: lvalue '.' ID .

    $default  reduce using rule 48 (member)


State 133

   58 methodcall: DOTDOT ID . '(' elist ')'

    '('  shift, and go to state 158


State 134

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
   51 member: call '[' expr . ']'

    AND  shift, and go to state 71
    OR   shift, and go to state 72
    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83
    ']'  shift, and go to state 159


State 135

   52 call: call '(' elist . ')'
   60 elist: elist . ',' expr

    ')'  shift, and go to state 160
    ','  shift, and go to state 151


State 136

   50 member: call '.' ID .

    $default  reduce using rule 50 (member)


State 137

   76 funcargs: '(' $@4 . idlist ')' $@5
   85 idlist: . ID
   86       | . idlist ',' ID
   87       | . %empty  [')', ',']

    ID  shift, and go to state 161

    $default  reduce using rule 87 (idlist)

    idlist  go to state 162


State 138

   77 funcbody: block .

    $default  reduce using rule 77 (funcbody)


State 139

   78 funcdef: funcprefix funcargs funcbody .

    $default  reduce using rule 78 (funcdef)


State 140

   90 elseprefix: ELSE .

    $default  reduce using rule 90 (elseprefix)


State 141

    4 stmt: . expr ';'
    5     | . ifstmt
    6     | . whilestmt
    7     | . forstmt
    8     | . returnstmt
    9     | . BREAK ';'
   10     | . CONTINUE ';'
   11     | . block
   12     | . funcdef
   13     | . ';'
   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   70 block: . '{' $@3 stmts '}'
   73 funcprefix: . FUNCTION funcname
   78 funcdef: . funcprefix funcargs funcbody
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL
   89 ifprefix: . IF $@6 '(' expr ')'
   91 ifstmt: . ifprefix stmt
   93       | . ifprefix stmt elseprefix stmt $@7
   93       | ifprefix stmt elseprefix . stmt $@7
   94 whilestmt: . whilestart whilecond stmt
   95 whilestart: . WHILE
  100 forprefix: . FOR $@8 '(' elist ';' M expr ';'
  102 forstmt: . forprefix N elist ')' N stmt $@9 N
  103 returnstmt: . RETURN expr ';'
  104           | . RETURN ';'

    IF          shift, and go to state 4
    WHILE       shift, and go to state 5
    FOR         shift, and go to state 6
    FUNCTION    shift, and go to state 7
    RETURN      shift, and go to state 8
    BREAK       shift, and go to state 9
    CONTINUE    shift, and go to state 10
    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '{'         shift, and go to state 19
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    ';'         shift, and go to state 22
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    stmt        go to state 163
    expr        go to state 29
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    block       go to state 37
    funcprefix  go to state 38
    funcdef     go to state 39
    const       go to state 40
    ifprefix    go to state 41
    ifstmt      go to state 42
    whilestmt   go to state 43
    whilestart  go to state 44
    forprefix   go to state 45
    forstmt     go to state 46
    returnstmt  go to state 47


State 142

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
   96 whilecond: '(' expr . ')'

    AND  shift, and go to state 71
    OR   shift, and go to state 72
    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83
    ')'  shift, and go to state 164


State 143

   94 whilestmt: whilestart whilecond stmt .

    $default  reduce using rule 94 (whilestmt)


State 144

   60 elist: elist . ',' expr
  102 forstmt: forprefix N elist . ')' N stmt $@9 N

    ')'  shift, and go to state 165
    ','  shift, and go to state 151


State 145

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
   89 ifprefix: IF $@6 '(' expr . ')'

    AND  shift, and go to state 71
    OR   shift, and go to state 72
    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83
    ')'  shift, and go to state 166


State 146

   60 elist: elist . ',' expr
  100 forprefix: FOR $@8 '(' elist . ';' M expr ';'

    ';'  shift, and go to state 167
    ','  shift, and go to state 151


State 147

   54 call: '(' funcdef ')' . '(' elist ')'

    '('  shift, and go to state 153


State 148

   70 block: '{' $@3 stmts '}' .

    $default  reduce using rule 70 (block)


State 149

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
   68 indexedelem: '{' $@2 expr . ':' expr '}'

    AND  shift, and go to state 71
    OR   shift, and go to state 72
    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83
    ':'  shift, and go to state 168


State 150

   63 objectdef: '[' $@1 elist ']' .

    $default  reduce using rule 63 (objectdef)


State 151

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   60 elist: elist ',' . expr
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 169
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 152

   66 indexed: indexed ',' indexedelem .

    $default  reduce using rule 66 (indexed)


State 153

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   54     | '(' funcdef ')' '(' . elist ')'
   59 elist: . expr
   60      | . elist ',' expr
   61      | . %empty  [')', ',']
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    $default  reduce using rule 61 (elist)

    expr        go to state 110
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    elist       go to state 170
    objectdef   go to state 36
    const       go to state 40


State 154

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
   27     | expr AND D expr .  [AND, OR, '}', ']', ')', ';', ',', ':']

    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83

    $default  reduce using rule 27 (expr)

    Conflict between rule 27 and token AND resolved as reduce (%left AND).
    Conflict between rule 27 and token OR resolved as reduce (OR < AND).
    Conflict between rule 27 and token '+' resolved as shift (AND < '+').
    Conflict between rule 27 and token '-' resolved as shift (AND < '-').
    Conflict between rule 27 and token '*' resolved as shift (AND < '*').
    Conflict between rule 27 and token '/' resolved as shift (AND < '/').
    Conflict between rule 27 and token '%' resolved as shift (AND < '%').
    Conflict between rule 27 and token EQ resolved as shift (AND < EQ).
    Conflict between rule 27 and token NE resolved as shift (AND < NE).
    Conflict between rule 27 and token LT resolved as shift (AND < LT).
    Conflict between rule 27 and token GT resolved as shift (AND < GT).
    Conflict between rule 27 and token GE resolved as shift (AND < GE).
    Conflict between rule 27 and token LE resolved as shift (AND < LE).


State 155

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   26     | expr OR D expr .  [OR, '}', ']', ')', ';', ',', ':']
   27     | expr . AND D expr

    AND  shift, and go to state 71
    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83

    $default  reduce using rule 26 (expr)

    Conflict between rule 26 and token AND resolved as shift (OR < AND).
    Conflict between rule 26 and token OR resolved as reduce (%left OR).
    Conflict between rule 26 and token '+' resolved as shift (OR < '+').
    Conflict between rule 26 and token '-' resolved as shift (OR < '-').
    Conflict between rule 26 and token '*' resolved as shift (OR < '*').
    Conflict between rule 26 and token '/' resolved as shift (OR < '/').
    Conflict between rule 26 and token '%' resolved as shift (OR < '%').
    Conflict between rule 26 and token EQ resolved as shift (OR < EQ).
    Conflict between rule 26 and token NE resolved as shift (OR < NE).
    Conflict between rule 26 and token LT resolved as shift (OR < LT).
    Conflict between rule 26 and token GT resolved as shift (OR < GT).
    Conflict between rule 26 and token GE resolved as shift (OR < GE).
    Conflict between rule 26 and token LE resolved as shift (OR < LE).


State 156

   49 member: lvalue '[' expr ']' .

    $default  reduce using rule 49 (member)


State 157

   57 normcall: '(' elist ')' .

    $default  reduce using rule 57 (normcall)


State 158

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   58 methodcall: DOTDOT ID '(' . elist ')'
   59 elist: . expr
   60      | . elist ',' expr
   61      | . %empty  [')', ',']
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    $default  reduce using rule 61 (elist)

    expr        go to state 110
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    elist       go to state 171
    objectdef   go to state 36
    const       go to state 40


State 159

   51 member: call '[' expr ']' .

    $default  reduce using rule 51 (member)


State 160

   52 call: call '(' elist ')' .

    $default  reduce using rule 52 (call)


State 161

   85 idlist: ID .

    $default  reduce using rule 85 (idlist)


State 162

   76 funcargs: '(' $@4 idlist . ')' $@5
   86 idlist: idlist . ',' ID

    ')'  shift, and go to state 172
    ','  shift, and go to state 173


State 163

   92 $@7: . %empty
   93 ifstmt: ifprefix stmt elseprefix stmt . $@7

    $default  reduce using rule 92 ($@7)

    $@7  go to state 174


State 164

   96 whilecond: '(' expr ')' .

    $default  reduce using rule 96 (whilecond)


State 165

   97 N: . %empty
  102 forstmt: forprefix N elist ')' . N stmt $@9 N

    $default  reduce using rule 97 (N)

    N  go to state 175


State 166

   89 ifprefix: IF $@6 '(' expr ')' .

    $default  reduce using rule 89 (ifprefix)


State 167

   98 M: . %empty
  100 forprefix: FOR $@8 '(' elist ';' . M expr ';'

    $default  reduce using rule 98 (M)

    M  go to state 176


State 168

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   68 indexedelem: '{' $@2 expr ':' . expr '}'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 177
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 169

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
   60 elist: elist ',' expr .  [']', ')', ';', ',']

    AND  shift, and go to state 71
    OR   shift, and go to state 72
    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83

    $default  reduce using rule 60 (elist)


State 170

   54 call: '(' funcdef ')' '(' elist . ')'
   60 elist: elist . ',' expr

    ')'  shift, and go to state 178
    ','  shift, and go to state 151


State 171

   58 methodcall: DOTDOT ID '(' elist . ')'
   60 elist: elist . ',' expr

    ')'  shift, and go to state 179
    ','  shift, and go to state 151


State 172

   75 $@5: . %empty
   76 funcargs: '(' $@4 idlist ')' . $@5

    $default  reduce using rule 75 ($@5)

    $@5  go to state 180


State 173

   86 idlist: idlist ',' . ID

    ID  shift, and go to state 181


State 174

   93 ifstmt: ifprefix stmt elseprefix stmt $@7 .

    $default  reduce using rule 93 (ifstmt)


State 175

    4 stmt: . expr ';'
    5     | . ifstmt
    6     | . whilestmt
    7     | . forstmt
    8     | . returnstmt
    9     | . BREAK ';'
   10     | . CONTINUE ';'
   11     | . block
   12     | . funcdef
   13     | . ';'
   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   70 block: . '{' $@3 stmts '}'
   73 funcprefix: . FUNCTION funcname
   78 funcdef: . funcprefix funcargs funcbody
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL
   89 ifprefix: . IF $@6 '(' expr ')'
   91 ifstmt: . ifprefix stmt
   93       | . ifprefix stmt elseprefix stmt $@7
   94 whilestmt: . whilestart whilecond stmt
   95 whilestart: . WHILE
  100 forprefix: . FOR $@8 '(' elist ';' M expr ';'
  102 forstmt: . forprefix N elist ')' N stmt $@9 N
  102        | forprefix N elist ')' N . stmt $@9 N
  103 returnstmt: . RETURN expr ';'
  104           | . RETURN ';'

    IF          shift, and go to state 4
    WHILE       shift, and go to state 5
    FOR         shift, and go to state 6
    FUNCTION    shift, and go to state 7
    RETURN      shift, and go to state 8
    BREAK       shift, and go to state 9
    CONTINUE    shift, and go to state 10
    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '{'         shift, and go to state 19
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    ';'         shift, and go to state 22
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    stmt        go to state 182
    expr        go to state 29
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    block       go to state 37
    funcprefix  go to state 38
    funcdef     go to state 39
    const       go to state 40
    ifprefix    go to state 41
    ifstmt      go to state 42
    whilestmt   go to state 43
    whilestart  go to state 44
    forprefix   go to state 45
    forstmt     go to state 46
    returnstmt  go to state 47


State 176

   14 expr: . assignexpr
   15     | . expr '+' expr
   16     | . expr '-' expr
   17     | . expr '*' expr
   18     | . expr '/' expr
   19     | . expr '%' expr
   20     | . expr GT expr
   21     | . expr GE expr
   22     | . expr LT expr
   23     | . expr LE expr
   24     | . expr EQ expr
   25     | . expr NE expr
   26     | . expr OR D expr
   27     | . expr AND D expr
   28     | . term
   30 term: . '(' expr ')'
   31     | . '-' expr
   32     | . NOT expr
   33     | . PLUSPLUS lvalue
   34     | . lvalue PLUSPLUS
   35     | . MINUSMINUS lvalue
   36     | . lvalue MINUSMINUS
   37     | . primary
   38 assignexpr: . lvalue '=' expr
   39 primary: . lvalue
   40        | . call
   41        | . objectdef
   42        | . '(' funcdef ')'
   43        | . const
   44 lvalue: . ID
   45       | . LOCAL ID
   46       | . COLONCOLON ID
   47       | . member
   48 member: . lvalue '.' ID
   49       | . lvalue '[' expr ']'
   50       | . call '.' ID
   51       | . call '[' expr ']'
   52 call: . call '(' elist ')'
   53     | . lvalue callsuffix
   54     | . '(' funcdef ')' '(' elist ')'
   63 objectdef: . '[' $@1 elist ']'
   64          | . '[' indexed ']'
   79 const: . INTEGER
   80      | . STRING
   81      | . NIL
   82      | . TRUE
   83      | . FALSE
   84      | . REAL
  100 forprefix: FOR $@8 '(' elist ';' M . expr ';'

    NOT         shift, and go to state 11
    LOCAL       shift, and go to state 12
    TRUE        shift, and go to state 13
    FALSE       shift, and go to state 14
    NIL         shift, and go to state 15
    '-'         shift, and go to state 16
    PLUSPLUS    shift, and go to state 17
    MINUSMINUS  shift, and go to state 18
    '['         shift, and go to state 20
    '('         shift, and go to state 21
    COLONCOLON  shift, and go to state 23
    ID          shift, and go to state 24
    STRING      shift, and go to state 25
    INTEGER     shift, and go to state 26
    REAL        shift, and go to state 27

    expr        go to state 183
    term        go to state 30
    assignexpr  go to state 31
    primary     go to state 32
    lvalue      go to state 33
    member      go to state 34
    call        go to state 35
    objectdef   go to state 36
    const       go to state 40


State 177

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
   68 indexedelem: '{' $@2 expr ':' expr . '}'

    AND  shift, and go to state 71
    OR   shift, and go to state 72
    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83
    '}'  shift, and go to state 184


State 178

   54 call: '(' funcdef ')' '(' elist ')' .

    $default  reduce using rule 54 (call)


State 179

   58 methodcall: DOTDOT ID '(' elist ')' .

    $default  reduce using rule 58 (methodcall)


State 180

   76 funcargs: '(' $@4 idlist ')' $@5 .

    $default  reduce using rule 76 (funcargs)


State 181

   86 idlist: idlist ',' ID .

    $default  reduce using rule 86 (idlist)


State 182

  101 $@9: . %empty
  102 forstmt: forprefix N elist ')' N stmt . $@9 N

    $default  reduce using rule 101 ($@9)

    $@9  go to state 185


State 183

   15 expr: expr . '+' expr
   16     | expr . '-' expr
   17     | expr . '*' expr
   18     | expr . '/' expr
   19     | expr . '%' expr
   20     | expr . GT expr
   21     | expr . GE expr
   22     | expr . LT expr
   23     | expr . LE expr
   24     | expr . EQ expr
   25     | expr . NE expr
   26     | expr . OR D expr
   27     | expr . AND D expr
  100 forprefix: FOR $@8 '(' elist ';' M expr . ';'

    AND  shift, and go to state 71
    OR   shift, and go to state 72
    '+'  shift, and go to state 73
    '-'  shift, and go to state 74
    '*'  shift, and go to state 75
    '/'  shift, and go to state 76
    '%'  shift, and go to state 77
    EQ   shift, and go to state 78
    NE   shift, and go to state 79
    LT   shift, and go to state 80
    GT   shift, and go to state 81
    GE   shift, and go to state 82
    LE   shift, and go to state 83
    ';'  shift, and go to state 186


State 184

   68 indexedelem: '{' $@2 expr ':' expr '}' .

    $default  reduce using rule 68 (indexedelem)


State 185

   97 N: . %empty
  102 forstmt: forprefix N elist ')' N stmt $@9 . N

    $default  reduce using rule 97 (N)

    N  go to state 187


State 186

  100 forprefix: FOR $@8 '(' elist ';' M expr ';' .

    $default  reduce using rule 100 (forprefix)


State 187

  102 forstmt: forprefix N elist ')' N stmt $@9 N .

    $default  reduce using rule 102 (forstmt)
